-- Part D â€“ Engineering Judgment & Reflection


Question 1. If the system scales to over 1 million orders, what would you optimize first and why?



Answer:

I would prioritize the following optimization in this order:

1. Database indexing and query optimization.
This provides the biggest immediate impact with minimal code changes. As the database grows, unoptimized queries become exponentially slower.
Indexing specific columns can do the initial optimization.

Specific Actions:
 - Index on (user_id, status, created_at) for common customer queries, and (status, created_at) for admin/manager dashboard; These covers WHERE and ORDER BY clauses in most queries.
 - Implement query result caching for frequently accessed data.
 - Use redis or any other caching mechanism for session data and frequently queried orders.


2. Implement pagination and lazy loading.
Prevents memory exhaustion and improves response time. No system can load 1M+ records at once (probably).

Specific actions:
 - Replace 'get()' with 'pagination()'.
 - Use cursor pagination for infinite scroll
 - Implement API rate limit to prevent abuse.

3. Optimize N+1 query with strategic eager loading.
I already explained it in part-a.txt. This optimization gives a huge impact in production, as N+1 query problem occures new query execution each loop.

4. Implement caching mechanism.
Caching mechanism reduces database load for frequently accessed, slowly changing data.
It saves the data in a cache for a specific time, and returns data from the cache instead of hiting the database in that time, unless explicitly cache is invalidated.

5. Database partitioning (for very large scale)
This step is only necessary when a single table exceeds 10M+ rows and query remains slow.
We can make a partition for the table, and insert data in chunks. This will improve performance for even 100M+ data in a table.



-------------------------------------------------


Questino 2. Which Laravel feature do developers misuse most in your opinion, and how do you avoid that misuse?



Answer:

Eloquent ORM and Relationships:

Eloquent is incredebly powerful and developer friendly, which actually leads to its misuse. Developers often:
    - Over-rely on eloquent's magic for everything, even when query builder or raw sql would be appropriate. (honestly, I have been doing the same for a long time.)
    - Create N+1 by not undestanding lazy vs eager loading.
    - Use models for operations that dont need ORM overhead.
    - Implement business logic directly in Model, violating the basic rules. (Honestly, I have dealt with this)
    - Misuse relationship caussing performance issues.


Misuse#1: N+1 query problem (most common)

Bad example:

$orders = Order::all(); // one query executed
foreach ($orders as $order) {
    echo $order->user->name; // +1 query on each order
}

To avoid it, eager load the 'user' relationship.

$orders = Order::with('user')->get(); // two query execution
foreach ($orders as $order) {
    echo $order->user->name; // direct access from loaded data
}



Misuse#2: Usage of eloquent for balk operations

Bad Example:

foreach ($data as $item) { // assuming $data has 1000 records
    Order::create($item); // Fires model events each time, 1000 queries executing
}


To fix, use 'insert()' method, or use chunk with proper timestamp.

Order::insert($data) // absolutely one query



Misuse#3: Implement business logic in models.

This is the most unnecessary and bad usage of models. Models are not for writing business logics in it. We can either write business logic in services or in controller direcly.


Misuse#4: Using eloquent when query builder would suffice

Bad usage:
$report = Order::where('status', 'completed')
    ->where('created_at', '>=', $startDate)
    ->get()
    ->sum('total_amount'); // Loads all record in memory then counts them.


Solution:

We can use both eloquent and query builder aggregation for this.

$report = Order::where('status', 'completed')
    ->where('created_at', '>=', $startDate)
    ->sum('total_amount'); // Lets the sql do the count part.



